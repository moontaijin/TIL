# Blocking-NonBlocking-Synchronous-Asynchronous



## 단어의 뜻

**동기(synchronous : 동시에 일어나는)**

 \- 동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속인데, 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 한다.

​	**-> 요청과 결과가 한 자리에서 동시에 일어남**

​	**-> A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞추겠다.**	



**비동기(Asynchronous : 동시에 일어나지 않는)**

 \- 비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을거라는 약속. 

​	**-> 요청한 그 자리에서 결과가 주어지지 않음**

​	**-> 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.**



## 장단점

### 동기(Sync)

* 장점 : 설계가 매우 간단하고 직관적이다.
* 단점 : 결과가 주어질 때가지 아무것도 못하고 대기해야한다.



### 비동기(Async)

* 장점 : 결과가 주어지는데 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있다.
* 단점 : 설계방식이 동기 방식보다 복잡하다.



## 예시

![img](https://t1.daumcdn.net/cfile/tistory/27298A4D57F8A1DF1D)

계좌이체의 경우 A계좌에서 B계좌로 돈을 보낼 때, 양측의 통장에서 출금과 입금이 동시에 이루어져야한다. 그렇지 않을경우 한쪽에서는 돈이 나갔는데 한쪽은 돈을 받지 못하는 경우가 생길 수 있기 때문이다. 이럴경우에는 계좌의 출금과 입금은 **동기(Sync)** 방식으로 처리하여 양측의 작업을 동시에 수행해야한다.



![img](https://t1.daumcdn.net/cfile/tistory/2466434B57F8A40A19)

시험문제를 풀고 채점하는 작업의 경우 문제를 푸는 작업과 채점을 하는 작업 모두 시험지를 통해서 이루어지지만 두 작업은 동시에 이루어지지 않는다. 작업들이 동시에 진행될 필요가 없으므로 위 작업은 **비동기(Async)** 방식으로 처리되었다고 생각 할 수 있다.



## Blocking-Nonblocking

동기와 비동기를 생각 할 때 빠질수 없는 개념이 Blocking과 Nonblocking이다. 아래 표를 살펴보자.

![Imgur](http://i.imgur.com/iSafBIF.png)

우리가 일반적으로 말하는 동기식 처리는 **Sync-Blocking**을, 비동기식 처리는 **Async-NonBlocking**을 말한다.

두 방식의 차이점은 다른 작업을  하는동안 본래 진행하던 작업을 계속 수행할 수 있냐의 차이라고 생각하면 편하다.  **Sync-Blocking**방식의 경우는 두 작업을 동시에 수행하지 못하고 호출한 작업의 결과가 나올때 까지 대기해야한다. 그러나 **Async-NonBlocking**방식의 경우는 호출과 동시에 요청을 잘 받았다는 확인 응답을 반환받은 후 본 작업을 다시 수행한다. 그러다보면 어느순간 Callback(Called at the back, 이전에 수행하라고 했던 작업이라고 생각하면 편하다)을 호출하여 작업을 완료한다.



## 잘 사용하지 않는것들

위 표에서 궁금해지는 점은 그렇다면 비어있는 두 곳, 즉 **Sync-NonBlocking**과 **Async-Blocking**은 어떤식으로 작업이 수행될지에 대한 궁금증이다. 위 두가지 경우는 잘 사용되지 않으므로 간단하게 그림과 어떤 케이스에서 사용되는지만 확인해보겠다.

![Imgur](http://i.imgur.com/a8xZ9No.png)

위 케이스는 ```future.isDone()``` 이라는 작업에서 사용된다고 한다. 이 함수가 뭔지 잘 몰라서 코드만 적어두겠다. 추후에 공부해야할듯

```vbscript
Future ft = asyncFileChannel.read(~~~);

while(!ft.isDone()) {
    // isDone()은 asyncChannle.read() 작업이 완료되지 않았다면 false를 바로 리턴해준다.
    // isDone()은 물어보면 대답을 해줄 뿐 작업 완료를 스스로 신경쓰지 않고,
    //     isDone()을 호출하는 쪽에서 계속 isDone()을 호출하면서 작업 완료를 신경쓴다.
    // asyncChannle.read()이 완료되지 않아도 여기에서 다른 작업 수행 가능 
}

// 작업이 완료되면 작업 결과에 따른 다른 작업 처리
```





![Imgur](http://i.imgur.com/zKF0CgK.png)

위 케이스는 Node.js와 MySQL의 조합, 즉 웹페이지와 DB의 관계에서 많이 사용된다고 하는데 이것도 공부해본것에 따르면 위 그림과 조금 다르게 진행된다. 실제 웹페이지에서는 **Async-NonBlocking**처럼 진행을 하는데, DB의 어떤 코드에서(대부분 while문과같은 반복문이라고 한다) **Sync-Blocking**과 같이 Blocking이 되어 작업이 대기된다고 한다. 이부분도 공부가 더 필요할듯...



## 정리

- **Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사**
  - 바로 리턴하지 않으면 Blocking
  - 바로 리턴하면 NonBlocking
- **Synchronous/Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사**
  - 호출되는 함수의 작업 완료를 호출한 함수가 신경쓰면 Synchronous
  - 호출되는 함수의 작업 완료를 호출된 함수가 신경쓰면 Asynchronous
- 성능과 자원의 효율적 사용 관점에서 가장 유리한 모델은 Async-NonBlocking 모델이다.