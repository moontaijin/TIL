# 해시 알고리즘(Hash Algorithm)



## 해시 테이블

  일반적인 검색트리는 원소 하나를 저장하고 검색하는 데 평균적으로 ![img](https://t1.daumcdn.net/cfile/tistory/211CBF4F539FF9691C)의 시간이 걸리고, 최악의 경우 ![img](https://t1.daumcdn.net/cfile/tistory/26382B50539FF91813)의 시간이 걸린다. 저장된 자료의 양에 상관없이 원소 하나를 저장, 검색하는 데 항상 상수 시간에 가능하게 할 수 없는지 사람들은 요구하게 되었고, 이 꿈을 실현한 것이 해시 테이블이다. 해시 테이블은 자료의 저장, 검색에 있어 극단적인 효율에 다다른 자료구조이다.



## 해시 함수

 임의의 원소를 해시 테이블에 저장하려면 해당 원소의 해시값(주소값)을 함수를 통해 계산해야하는데, 이때 함수의 리턴값을 다음 두 가지 성질을 가지도록 해야한다.

1. 입력 원소가 해시 테이블 전체에 고루 저장되어야 한다.
2. 계산이 간단해야 한다.



이 때, 첫 번째 성질이 가장 중요한데 이 성질을 잘 만족해야 한 주소를 놓고 충돌할 확률이 작아지기 때문이다.



#### 1. 나누기 방법

나누기 방법은 원소를 해시 테이블의 크기로 나누어 나머지의 값을 테이블의 주소로 사용하여 저장하는 방법이다.

![img](https://t1.daumcdn.net/cfile/tistory/210A083A539FFFD001)

일반적으로 다음과 같은 식을 가진다.



#### 2. 곱하기 방법

나누기 방법은 해시 테이블 크기보다 큰 수를 해시 테이블 크기 범위에 들어오도록 수축시킨다. 곱하기 방법은 이와 반대로 먼저 입력값을 0과 1사이의 소수로 대응시킨 후 해시 테이블 크기 m을 곱하여 0~m-1 사이로 팽창시킨다**(정규화하는 것과 같다.)**

![img](https://t1.daumcdn.net/cfile/tistory/2266243853A002070A)

일반적으로 다음과 같은 식을 가진다.





## 충돌해결

위에서 말했듯이 해시는 아무리 함수가 좋더라도 서로 다른 값이 같은 주소를 가지는 경우가 발생한다.

이 때, 이를 해결하기위한 방법으로는 크게 2가지가 존재한다.



 ### 1. 체이닝(Chaining)

체이팅에서는 같은 주소로 해싱되는 원소를 모두 하나의 연결리스트에 매달아 관리한다.

![img](https://t1.daumcdn.net/cfile/tistory/273BBA4453A0179F24)

체이닝에서 삽입은 효율성을 위해 연결리스트의 맨 앞에 삽입한다. O(1)

탐색과 삭제는 값에 맞는 주소로 가서 탐색을 해야한다. O(N)





### 2. 개방주소(Open Addressing)

개방주소 방법은 체이닝과 같은 추가 공간을 허용하지 않고 주어진 해시 테이블 공간 내에서 해결한다. 먼저 해시 함수를 계산하여   계산된 주소를 차지하고 있는 다른 원소가 없으면 그 자리에 넣고, 이미 그 자리를 차지한 원소가 있으면 정해진 규칙에 따라 다음 자리를 찾게된다. 처음 계산한 해쉬 함수를 0번째 해쉬함수, 충돌이 일어나서 다음 주소를 계산하는 것을 1번째 해쉬함수 ... 이런식으로 표현한다.



다음 주소를 결정하는 방법에는 크게 선형 조사(Linear Probing), 이차원 조사(Quadratic Probing), 더블 해싱(Double Hashing)이 존재한다.



### 2-1. 선형 조사(Linear Probing)

선형 조사는 가장 간단한 충돌 해결 방법으로, 충돌이 일어난 바로 뒷자리를 보는 것이다. 이렇게 하면 i번째 해쉬 함수는 h(x)로 부터 i만큼 떨어진 자리가 된다. 테이블의 경계를 넘어갈 경우에는 맨 앞으로 돌아간다.

![img](https://t1.daumcdn.net/cfile/tistory/2549044A53A0221627)



  선형 조사의 경우 **특정 영역에 원소가 몰릴 때는 치명적으로 성능이 떨어진다.** 이런 형상을 1차 군집(Primary Clustering)이라 한다. 이렇게 되면 평균 검색 시간과 삽입 시간이 증가하게 된다.



### 2-2. 이차원 조사(Quadratic Probing)

이차원 조사는  바로 뒷자리를 보는 선형 조사와 달리 보폭을 이차함수에 의해 넓혀가면서 본다. 예를 들면, i번째 해시 함수를 h(x)로 부터 i^2만큼 떨어진 자리로 삼을 수 있다. 즉, h(x), h(x)+1, h(x)+4, h(x)+9, h(x)+16.... 과 같이 볼 수 있다.



![img](https://t1.daumcdn.net/cfile/tistory/2768B54A53A024C903)



이렇게 하면 선형 조사에서처럼 특정 영역에 원소가 몰려도 그 영역을 빨리 벗어날 수 있다. 그러나 여러 개의 원소가 동일한 초기 해시 함수값을 갖게 되면 모두 같은 순서로 조사를 할 수 밖에 없어 비효율적이 된다. 이런 현상을 2차 군집(Secondary Clustering)이라 한다.



### 2-3. 더블 해싱(Double Hashing)

더블 해싱은 두 개의 함수를 사용한다. 더블 해슁에서 i번째 해시 함수는 다음과 같다.



![img](https://t1.daumcdn.net/cfile/tistory/264FC33853A0272638)



여기서 h(x)와 f(x)는 서로 다른 해시 함수이다. 충돌이 생겨 다음에 볼 주소를 계산할 때 두 번째 해시 함수값 만큼씩 점프를 한다.



![img](https://t1.daumcdn.net/cfile/tistory/253AAF4F53A027F624)



더블 해싱에서 조심할 점은 두 번째 해쉬 함수 값 f(x)가 해시 테이블 크기 m과 서로 소인 값이어야 한다는 것이다. 만일 f(x)와 m이 1보다 큰 최소공약수 d를 가지면 x의 자리를 찾기 위해 해시 테이블 전체 중 기껏해야 1/d 밖에 보지 못하게 된다.



두 개의 해시 함수를 정하는 데 있어서 권장하는 방법은 h(x) = x mod m 으로 잡고, m보다 조금 작은 소수 m' 에 대해 f(x) = 1 + (x mod m')으로 잡는 것이다. 또한 2의 지수승으로 잡는것은 좋지 않으므로, 가장 좋은 수는 m에 가까운 2의 지수승보다 작은 소수로 잡는것이다.



### 2-4. 삭제시 주의점

개방주소 방식에서 조심해야할 것은 원소를 삭제했을 경우이다.



![img](https://t1.daumcdn.net/cfile/tistory/2455F93553A02B530F)



위 예는 선형조사에서의 삭제로 (a)에서 1을 삭제하면 (b)에서 38을 삽입할때 1의 자리를 검사하여 없는 자리인 줄 알고 38을 1의 자리에 삽입할 수 있다. 이러면 삽입의 순서가 뒤틀리게 된다. 그리하여 삭제할 경우 그 자리에 DELETED 라는 상수값을 저장하여 삭제된 자리라는 것을 표시하여야 한다.